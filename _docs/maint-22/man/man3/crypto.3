.TH crypto 3 "crypto 4.6.5.2" "Ericsson AB" "Erlang Module Definition"
.SH NAME
crypto \- Crypto Functions
.SH DESCRIPTION
.LP
This module provides a set of cryptographic functions\&.
.RS 2
.TP 2
.B
Hash functions:

.RS 2
.TP 2
.B
SHA1, SHA2:
 Secure Hash Standard [FIPS PUB 180-4] 
.TP 2
.B
SHA3:
 SHA-3 Standard: Permutation-Based Hash and Extendable-Output Functions [FIPS PUB 202] 
.TP 2
.B
BLAKE2:
BLAKE2 â€” fast secure hashing
.TP 2
.B
MD5:
The MD5 Message Digest Algorithm [RFC 1321]
.TP 2
.B
MD4:
The MD4 Message Digest Algorithm [RFC 1320]
.RE
.RS 2
.LP

.RE
.TP 2
.B
MACs - Message Authentication Codes:

.RS 2
.TP 2
.B
Hmac functions:
 Keyed-Hashing for Message Authentication [RFC 2104] 
.TP 2
.B
Cmac functions:
 The AES-CMAC Algorithm [RFC 4493] 
.TP 2
.B
POLY1305:
 ChaCha20 and Poly1305 for IETF Protocols [RFC 7539] 
.RE
.RS 2
.LP

.RE
.TP 2
.B
Symmetric Ciphers:

.RS 2
.TP 2
.B
DES, 3DES and AES:
Block Cipher Techniques [NIST]
.TP 2
.B
Blowfish:
 Fast Software Encryption, Cambridge Security Workshop Proceedings (December 1993), Springer-Verlag, 1994, pp\&. 191-204\&. 
.TP 2
.B
Chacha20:
 ChaCha20 and Poly1305 for IETF Protocols [RFC 7539] 
.TP 2
.B
Chacha20_poly1305:
 ChaCha20 and Poly1305 for IETF Protocols [RFC 7539] 
.RE
.RS 2
.LP

.RE
.TP 2
.B
Modes:

.RS 2
.TP 2
.B
ECB, CBC, CFB, OFB and CTR:
 Recommendation for Block Cipher Modes of Operation: Methods and Techniques [NIST SP 800-38A] 
.TP 2
.B
GCM:
 Recommendation for Block Cipher Modes of Operation: Galois/Counter Mode (GCM) and GMAC [NIST SP 800-38D] 
.TP 2
.B
CCM:
 Recommendation for Block Cipher Modes of Operation: The CCM Mode for Authentication and Confidentiality [NIST SP 800-38C] 
.RE
.RS 2
.LP

.RE
.TP 2
.B
Asymetric Ciphers - Public Key Techniques:

.RS 2
.TP 2
.B
RSA:
 PKCS #1: RSA Cryptography Specifications [RFC 3447] 
.TP 2
.B
DSS:
 Digital Signature Standard (DSS) [FIPS 186-4] 
.TP 2
.B
ECDSA:
 Elliptic Curve Digital Signature Algorithm [ECDSA] 
.TP 2
.B
SRP:
 The SRP Authentication and Key Exchange System [RFC 2945] 
.RE
.RS 2
.LP

.RE
.RE
.LP

.RS -4
.B
Note:
.RE
The actual supported algorithms and features depends on their availability in the actual libcrypto used\&. See the \fBcrypto (App)\fR\& about dependencies\&.
.LP
Enabling FIPS mode will also disable algorithms and features\&.

.LP
The \fBCRYPTO User\&'s Guide\fR\& has more information on FIPS, Engines and Algorithm Details like key lengths\&.
.SH DATA TYPES
.SS Ciphers, new API
.nf

\fBcipher()\fR\& = \fBcipher_no_iv()\fR\& | \fBcipher_iv()\fR\& | \fBcipher_aead()\fR\&
.br
.fi
.RS
.RE
.nf

\fBcipher_no_iv()\fR\& = 
.br
    aes_128_ecb | aes_192_ecb | aes_256_ecb | blowfish_ecb |
.br
    des_ecb | rc4
.br
.fi
.RS
.RE
.nf

\fBcipher_iv()\fR\& = 
.br
    aes_128_cbc | aes_192_cbc | aes_256_cbc | aes_128_cfb128 |
.br
    aes_192_cfb128 | aes_256_cfb128 | aes_128_cfb8 |
.br
    aes_192_cfb8 | aes_256_cfb8 | aes_128_ctr | aes_192_ctr |
.br
    aes_256_ctr | aes_ige256 | blowfish_cbc | blowfish_cfb64 |
.br
    blowfish_ofb64 | chacha20 | des_ede3_cbc | des_ede3_cfb |
.br
    des_cbc | des_cfb | rc2_cbc
.br
.fi
.RS
.RE
.nf

\fBcipher_aead()\fR\& = 
.br
    aes_128_ccm | aes_192_ccm | aes_256_ccm | aes_128_gcm |
.br
    aes_192_gcm | aes_256_gcm | chacha20_poly1305
.br
.fi
.RS
.LP
Ciphers known by the CRYPTO application when using the \fBnew API\fR\&\&.
.LP
Note that this list might be reduced if the underlying libcrypto does not support all of them\&.
.RE
.SS Ciphers, old API
.nf

\fBblock_cipher_with_iv()\fR\& = 
.br
    \fBcbc_cipher()\fR\& | \fBcfb_cipher()\fR\& | blowfish_ofb64 | aes_ige256
.br
.fi
.RS
.RE
.nf

\fBblock_cipher_without_iv()\fR\& = \fBecb_cipher()\fR\&
.br
.fi
.RS
.RE
.nf

\fBstream_cipher()\fR\& = \fBctr_cipher()\fR\& | chacha20 | rc4
.br
.fi
.RS
.RE
.nf

\fBaead_cipher()\fR\& = aes_gcm | aes_ccm | chacha20_poly1305
.br
.fi
.RS
.RE
.nf

\fBcbc_cipher()\fR\& = 
.br
    aes_128_cbc | aes_192_cbc | aes_256_cbc | blowfish_cbc |
.br
    des_cbc | des_ede3_cbc | rc2_cbc |
.br
    \fBretired_cbc_cipher_aliases()\fR\&
.br
.fi
.RS
.RE
.nf

\fBcfb_cipher()\fR\& = 
.br
    aes_128_cfb128 | aes_192_cfb128 | aes_256_cfb128 |
.br
    aes_128_cfb8 | aes_192_cfb8 | aes_256_cfb8 | blowfish_cfb64 |
.br
    des_cfb | des_ede3_cfb |
.br
    \fBretired_cfb_cipher_aliases()\fR\&
.br
.fi
.RS
.RE
.nf

\fBctr_cipher()\fR\& = 
.br
    aes_128_ctr | aes_192_ctr | aes_256_ctr |
.br
    \fBretired_ctr_cipher_aliases()\fR\&
.br
.fi
.RS
.RE
.nf

\fBecb_cipher()\fR\& = 
.br
    aes_128_ecb | aes_192_ecb | aes_256_ecb | blowfish_ecb |
.br
    \fBretired_ecb_cipher_aliases()\fR\&
.br
.fi
.RS
.LP
Ciphers known by the CRYPTO application when using the \fBold API\fR\&\&.
.LP
Note that this list might be reduced if the underlying libcrypto does not support all of them\&.
.RE
.nf

\fBretired_cbc_cipher_aliases()\fR\& = 
.br
    aes_cbc | aes_cbc128 | aes_cbc256 | des3_cbc | des_ede3
.br
.fi
.RS
.RE
.nf

\fBretired_cfb_cipher_aliases()\fR\& = 
.br
    aes_cfb8 | aes_cfb128 | des3_cbf | des3_cfb | des_ede3_cbf
.br
.fi
.RS
.RE
.nf

\fBretired_ctr_cipher_aliases()\fR\& = aes_ctr
.br
.fi
.RS
.RE
.nf

\fBretired_ecb_cipher_aliases()\fR\& = aes_ecb
.br
.fi
.RS
.LP
Alternative, old names of ciphers known by the CRYPTO application when using the \fBold API\fR\&\&. See \fBRetired cipher names\fR\& for names to use instead to be prepared for an easy convertion to the \fBnew API\fR\&\&.
.LP
Note that this list might be reduced if the underlying libcrypto does not support all of them\&.
.RE
.SS Digests and hash
.nf

\fBhash_algorithm()\fR\& = 
.br
    \fBsha1()\fR\& |
.br
    \fBsha2()\fR\& |
.br
    \fBsha3()\fR\& |
.br
    \fBblake2()\fR\& |
.br
    ripemd160 |
.br
    \fBcompatibility_only_hash()\fR\&
.br
.fi
.RS
.RE
.nf

\fBhmac_hash_algorithm()\fR\& = 
.br
    \fBsha1()\fR\& | \fBsha2()\fR\& | \fBsha3()\fR\& | \fBcompatibility_only_hash()\fR\&
.br
.fi
.RS
.RE
.nf

\fBcmac_cipher_algorithm()\fR\& = 
.br
    aes_128_cbc | aes_192_cbc | aes_256_cbc | blowfish_cbc |
.br
    des_cbc | des_ede3_cbc | rc2_cbc | aes_128_cfb128 |
.br
    aes_192_cfb128 | aes_256_cfb128 | aes_128_cfb8 |
.br
    aes_192_cfb8 | aes_256_cfb8
.br
.fi
.RS
.RE
.nf

\fBrsa_digest_type()\fR\& = \fBsha1()\fR\& | \fBsha2()\fR\& | md5 | ripemd160
.br
.fi
.RS
.RE
.nf

\fBdss_digest_type()\fR\& = \fBsha1()\fR\& | \fBsha2()\fR\&
.br
.fi
.RS
.RE
.nf

\fBecdsa_digest_type()\fR\& = \fBsha1()\fR\& | \fBsha2()\fR\&
.br
.fi
.RS
.RE
.nf

\fBsha1()\fR\& = sha
.br
.fi
.nf

\fBsha2()\fR\& = sha224 | sha256 | sha384 | sha512
.br
.fi
.nf

\fBsha3()\fR\& = sha3_224 | sha3_256 | sha3_384 | sha3_512
.br
.fi
.nf

\fBblake2()\fR\& = blake2b | blake2s
.br
.fi
.RS
.RE
.nf

\fBcompatibility_only_hash()\fR\& = md5 | md4
.br
.fi
.RS
.LP
The \fIcompatibility_only_hash()\fR\& algorithms are recommended only for compatibility with existing applications\&.
.RE
.SS Elliptic Curves
.nf

\fBec_named_curve()\fR\& = 
.br
    brainpoolP160r1 | brainpoolP160t1 | brainpoolP192r1 |
.br
    brainpoolP192t1 | brainpoolP224r1 | brainpoolP224t1 |
.br
    brainpoolP256r1 | brainpoolP256t1 | brainpoolP320r1 |
.br
    brainpoolP320t1 | brainpoolP384r1 | brainpoolP384t1 |
.br
    brainpoolP512r1 | brainpoolP512t1 | c2pnb163v1 | c2pnb163v2 |
.br
    c2pnb163v3 | c2pnb176v1 | c2pnb208w1 | c2pnb272w1 |
.br
    c2pnb304w1 | c2pnb368w1 | c2tnb191v1 | c2tnb191v2 |
.br
    c2tnb191v3 | c2tnb239v1 | c2tnb239v2 | c2tnb239v3 |
.br
    c2tnb359v1 | c2tnb431r1 | ipsec3 | ipsec4 | prime192v1 |
.br
    prime192v2 | prime192v3 | prime239v1 | prime239v2 |
.br
    prime239v3 | prime256v1 | secp112r1 | secp112r2 | secp128r1 |
.br
    secp128r2 | secp160k1 | secp160r1 | secp160r2 | secp192k1 |
.br
    secp192r1 | secp224k1 | secp224r1 | secp256k1 | secp256r1 |
.br
    secp384r1 | secp521r1 | sect113r1 | sect113r2 | sect131r1 |
.br
    sect131r2 | sect163k1 | sect163r1 | sect163r2 | sect193r1 |
.br
    sect193r2 | sect233k1 | sect233r1 | sect239k1 | sect283k1 |
.br
    sect283r1 | sect409k1 | sect409r1 | sect571k1 | sect571r1 |
.br
    wtls1 | wtls10 | wtls11 | wtls12 | wtls3 | wtls4 | wtls5 |
.br
    wtls6 | wtls7 | wtls8 | wtls9
.br
.fi
.nf

\fBedwards_curve_dh()\fR\& = x25519 | x448
.br
.fi
.nf

\fBedwards_curve_ed()\fR\& = ed25519 | ed448
.br
.fi
.RS
.LP
Note that some curves are disabled if FIPS is enabled\&.
.RE
.nf

\fBec_explicit_curve()\fR\& = 
.br
    {Field :: \fBec_field()\fR\&,
.br
     Curve :: \fBec_curve()\fR\&,
.br
     BasePoint :: binary(),
.br
     Order :: binary(),
.br
     CoFactor :: none | binary()}
.br
.fi
.nf

\fBec_field()\fR\& = \fBec_prime_field()\fR\& | \fBec_characteristic_two_field()\fR\&
.br
.fi
.nf

\fBec_curve()\fR\& = 
.br
    {A :: binary(), B :: binary(), Seed :: none | binary()}
.br
.fi
.RS
.LP
Parametric curve definition\&.
.RE
.nf

\fBec_prime_field()\fR\& = {prime_field, Prime :: integer()}
.br
.fi
.nf

\fBec_characteristic_two_field()\fR\& = 
.br
    {characteristic_two_field,
.br
     M :: integer(),
.br
     Basis :: \fBec_basis()\fR\&}
.br
.fi
.nf

\fBec_basis()\fR\& = 
.br
    {tpbasis, K :: integer() >= 0} |
.br
    {ppbasis,
.br
     K1 :: integer() >= 0,
.br
     K2 :: integer() >= 0,
.br
     K3 :: integer() >= 0} |
.br
    onbasis
.br
.fi
.RS
.LP
Curve definition details\&.
.RE
.SS Keys
.nf

\fBkey()\fR\& = iodata()
.br
.fi
.nf

\fBdes3_key()\fR\& = [\fBkey()\fR\&]
.br
.fi
.RS
.LP
For keylengths, iv-sizes and blocksizes see the \fBUser\&'s Guide\fR\&\&.
.LP
A key for des3 is a list of three iolists
.RE
.nf

\fBkey_integer()\fR\& = integer() | binary()
.br
.fi
.RS
.LP
Always \fIbinary()\fR\& when used as return value
.RE
.SS Public/Private Keys
.nf

\fBrsa_public()\fR\& = [\fBkey_integer()\fR\&]
.br
.fi
.nf

\fBrsa_private()\fR\& = [\fBkey_integer()\fR\&]
.br
.fi
.nf

\fBrsa_params()\fR\& = 
.br
    {ModulusSizeInBits :: integer(),
.br
     PublicExponent :: \fBkey_integer()\fR\&}
.br
.fi
.RS
.LP
.nf
rsa_public() = [E, N]
.fi
.LP
.nf
rsa_private() = [E, N, D] | [E, N, D, P1, P2, E1, E2, C]
.fi
.LP
Where E is the public exponent, N is public modulus and D is the private exponent\&. The longer key format contains redundant information that will make the calculation faster\&. P1,P2 are first and second prime factors\&. E1,E2 are first and second exponents\&. C is the CRT coefficient\&. Terminology is taken from  RFC 3447\&.
.RE
.nf

\fBdss_public()\fR\& = [\fBkey_integer()\fR\&]
.br
.fi
.nf

\fBdss_private()\fR\& = [\fBkey_integer()\fR\&]
.br
.fi
.RS
.LP
.nf
dss_public() = [P, Q, G, Y] 
.fi
.LP
Where P, Q and G are the dss parameters and Y is the public key\&.
.LP
.nf
dss_private() = [P, Q, G, X] 
.fi
.LP
Where P, Q and G are the dss parameters and X is the private key\&.
.RE
.nf

\fBecdsa_public()\fR\& = \fBkey_integer()\fR\&
.br
.fi
.nf

\fBecdsa_private()\fR\& = \fBkey_integer()\fR\&
.br
.fi
.nf

\fBecdsa_params()\fR\& = \fBec_named_curve()\fR\& | \fBec_explicit_curve()\fR\&
.br
.fi
.RS
.RE
.nf

\fBeddsa_public()\fR\& = \fBkey_integer()\fR\&
.br
.fi
.nf

\fBeddsa_private()\fR\& = \fBkey_integer()\fR\&
.br
.fi
.nf

\fBeddsa_params()\fR\& = \fBedwards_curve_ed()\fR\&
.br
.fi
.RS
.RE
.nf

\fBsrp_public()\fR\& = \fBkey_integer()\fR\&
.br
.fi
.nf

\fBsrp_private()\fR\& = \fBkey_integer()\fR\&
.br
.fi
.RS
.LP
.nf
srp_public() = key_integer() 
.fi
.LP
Where is \fIA\fR\& or \fIB\fR\& from SRP design
.LP
.nf
srp_private() = key_integer() 
.fi
.LP
Where is \fIa\fR\& or \fIb\fR\& from SRP design
.RE
.nf

\fBsrp_gen_params()\fR\& = 
.br
    {user, \fBsrp_user_gen_params()\fR\&} | {host, \fBsrp_host_gen_params()\fR\&}
.br
.fi
.nf

\fBsrp_comp_params()\fR\& = 
.br
    {user, \fBsrp_user_comp_params()\fR\&} |
.br
    {host, \fBsrp_host_comp_params()\fR\&}
.br
.fi
.RS
.LP
.nf
srp_user_gen_params() = [DerivedKey::binary(), Prime::binary(), Generator::binary(), Version::atom()]
.fi
.LP
.nf
srp_host_gen_params() = [Verifier::binary(), Prime::binary(), Version::atom() ]
.fi
.LP
.nf
srp_user_comp_params() = [DerivedKey::binary(), Prime::binary(), Generator::binary(), Version::atom() | ScramblerArg::list()]
.fi
.LP
.nf
srp_host_comp_params() = [Verifier::binary(), Prime::binary(), Version::atom() | ScramblerArg::list()]
.fi
.LP
Where Verifier is \fIv\fR\&, Generator is \fIg\fR\& and Prime is\fI N\fR\&, DerivedKey is \fIX\fR\&, and Scrambler is \fIu\fR\& (optional will be generated if not provided) from SRP design Version = \&'3\&' | \&'6\&' | \&'6a\&'
.RE
.SS Public Key Ciphers
.nf

\fBpk_encrypt_decrypt_algs()\fR\& = rsa
.br
.fi
.RS
.LP
Algorithms for public key encrypt/decrypt\&. Only RSA is supported\&.
.RE
.nf

\fBpk_encrypt_decrypt_opts()\fR\& = [\fBrsa_opt()\fR\&] | \fBrsa_compat_opts()\fR\&
.br
.fi
.nf

\fBrsa_opt()\fR\& = 
.br
    {rsa_padding, \fBrsa_padding()\fR\&} |
.br
    {signature_md, atom()} |
.br
    {rsa_mgf1_md, sha} |
.br
    {rsa_oaep_label, binary()} |
.br
    {rsa_oaep_md, sha}
.br
.fi
.nf

\fBrsa_padding()\fR\& = 
.br
    rsa_pkcs1_padding | rsa_pkcs1_oaep_padding |
.br
    rsa_sslv23_padding | rsa_x931_padding | rsa_no_padding
.br
.fi
.RS
.LP
Options for public key encrypt/decrypt\&. Only RSA is supported\&.
.LP

.RS -4
.B
Warning:
.RE
.LP
The RSA options are experimental\&.
.LP
The exact set of options and there syntax \fImay\fR\& be changed without prior notice\&.

.RE
.nf

\fBrsa_compat_opts()\fR\& = [{rsa_pad, \fBrsa_padding()\fR\&}] | \fBrsa_padding()\fR\&
.br
.fi
.RS
.LP
Those option forms are kept only for compatibility and should not be used in new code\&.
.RE
.SS Public Key Sign and Verify
.nf

\fBpk_sign_verify_algs()\fR\& = rsa | dss | ecdsa | eddsa
.br
.fi
.RS
.LP
Algorithms for sign and verify\&.
.RE
.nf

\fBpk_sign_verify_opts()\fR\& = [\fBrsa_sign_verify_opt()\fR\&]
.br
.fi
.nf

\fBrsa_sign_verify_opt()\fR\& = 
.br
    {rsa_padding, \fBrsa_sign_verify_padding()\fR\&} |
.br
    {rsa_pss_saltlen, integer()} |
.br
    {rsa_mgf1_md, \fBsha2()\fR\&}
.br
.fi
.nf

\fBrsa_sign_verify_padding()\fR\& = 
.br
    rsa_pkcs1_padding | rsa_pkcs1_pss_padding | rsa_x931_padding |
.br
    rsa_no_padding
.br
.fi
.RS
.LP
Options for sign and verify\&.
.LP

.RS -4
.B
Warning:
.RE
.LP
The RSA options are experimental\&.
.LP
The exact set of options and there syntax \fImay\fR\& be changed without prior notice\&.

.RE
.SS Diffie-Hellman Keys and parameters
.nf

\fBdh_public()\fR\& = \fBkey_integer()\fR\&
.br
.fi
.nf

\fBdh_private()\fR\& = \fBkey_integer()\fR\&
.br
.fi
.RS
.RE
.nf

\fBdh_params()\fR\& = [\fBkey_integer()\fR\&]
.br
.fi
.RS
.LP
.nf
dh_params() = [P, G] | [P, G, PrivateKeyBitLength]
.fi
.RE
.nf

\fBecdh_public()\fR\& = \fBkey_integer()\fR\&
.br
.fi
.nf

\fBecdh_private()\fR\& = \fBkey_integer()\fR\&
.br
.fi
.nf

\fBecdh_params()\fR\& = 
.br
    \fBec_named_curve()\fR\& | \fBedwards_curve_dh()\fR\& | \fBec_explicit_curve()\fR\&
.br
.fi
.RS
.RE
.SS Types for Engines
.nf

\fBengine_key_ref()\fR\& = 
.br
    #{engine := \fBengine_ref()\fR\&,
.br
      key_id := \fBkey_id()\fR\&,
.br
      password => \fBpassword()\fR\&,
.br
      term() => term()}
.br
.fi
.nf

\fBengine_ref()\fR\& = term()
.br
.fi
.RS
.LP
The result of a call to \fBengine_load/3\fR\&\&.
.RE
.nf

\fBkey_id()\fR\& = string() | binary()
.br
.fi
.RS
.LP
Identifies the key to be used\&. The format depends on the loaded engine\&. It is passed to the \fIENGINE_load_(private|public)_key\fR\& functions in libcrypto\&.
.RE
.nf

\fBpassword()\fR\& = string() | binary()
.br
.fi
.RS
.LP
The password of the key stored in an engine\&.
.RE
.nf

\fBengine_method_type()\fR\& = 
.br
    engine_method_rsa | engine_method_dsa | engine_method_dh |
.br
    engine_method_rand | engine_method_ecdh |
.br
    engine_method_ecdsa | engine_method_ciphers |
.br
    engine_method_digests | engine_method_store |
.br
    engine_method_pkey_meths | engine_method_pkey_asn1_meths |
.br
    engine_method_ec
.br
.fi
.nf

\fBengine_cmnd()\fR\& = {\fBunicode:chardata()\fR\&, \fBunicode:chardata()\fR\&}
.br
.fi
.RS
.LP
Pre and Post commands for \fBengine_load/3 and /4\fR\&\&.
.RE
.SS Internal data types
.nf

\fBcrypto_state()\fR\&
.br
.fi
.nf

\fBhash_state()\fR\&
.br
.fi
.nf

\fBhmac_state()\fR\&
.br
.fi
.nf

\fBmac_state()\fR\&
.br
.fi
.nf

\fBstream_state()\fR\&
.br
.fi
.RS
.LP
Contexts with an internal state that should not be manipulated but passed between function calls\&.
.RE
.SS Error types
.nf

\fBrun_time_error()\fR\& = no_return()
.br
.fi
.RS
.LP
The exception \fIerror:badarg\fR\& signifies that one or more arguments are of wrong data type, or are otherwise badly formed\&.
.LP
The exception \fIerror:notsup\fR\& signifies that the algorithm is known but is not supported by current underlying libcrypto or explicitly disabled when building that\&.
.LP
For a list of supported algorithms, see \fBsupports/0\fR\&\&.
.RE
.nf

\fBdescriptive_error()\fR\& = no_return()
.br
.fi
.RS
.LP
This is a more developed variant of the older \fBrun_time_error()\fR\&\&.
.LP
The exception is:
.LP
.nf

	  {Tag, {C_FileName,LineNumber}, Description}

	   Tag = badarg | notsup | error
	   C_FileName = string()
	   LineNumber = integer()
	   Description = string()
	
.fi
.LP
It is like the older type an exception of the \fIerror\fR\& class\&. In addition they contain a descriptive text in English\&. That text is targeted to a developer\&. Examples are "Bad key size" or "Cipher id is not an atom"\&.
.LP
The exception tags are:
.RS 2
.TP 2
.B
\fIbadarg\fR\&:
Signifies that one or more arguments are of wrong data type or are otherwise badly formed\&.
.TP 2
.B
\fInotsup\fR\&:
Signifies that the algorithm is known but is not supported by current underlying libcrypto or explicitly disabled when building that one\&.
.TP 2
.B
\fIerror\fR\&:
An error condition that should not occur, for example a memory allocation failed or the underlying cryptolib returned an error code, for example "Can\&'t initialize context, step 1"\&. Thoose text usually needs searching the C-code to be understood\&.
.RE
.LP
To catch the exception, use for example:
.LP
.nf

	  try crypto:crypto_init(Ciph, Key, IV, true)
	  catch
	      error:{Tag, {C_FileName,LineNumber}, Description} ->
	              do_something(......)
	      .....
	  end
	
.fi
.RE
.SH "NEW API"

.SH EXPORTS
.LP
.nf

.B
crypto_init(Cipher, Key, EncryptFlag) ->
.B
               State | descriptive_error()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Cipher = \fBcipher_no_iv()\fR\&
.br
Key = iodata()
.br
EncryptFlag = boolean()
.br
State = \fBcrypto_state()\fR\&
.br
.RE
.RE
.RS
.LP
As \fBcrypto_init/4\fR\& but for ciphers without IVs\&.
.RE
.LP
.nf

.B
crypto_init(Cipher, Key, IV, EncryptFlag) ->
.B
               State | descriptive_error()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Cipher = \fBcipher_iv()\fR\&
.br
Key = IV = iodata()
.br
EncryptFlag = boolean()
.br
State = \fBcrypto_state()\fR\&
.br
.RE
.RE
.RS
.LP
Part of the \fBnew API\fR\&\&. Initializes a series of encryptions or decryptions and creates an internal state with a reference that is returned\&. The actual encryption or decryption is done by \fBcrypto_update/2\fR\&\&.
.LP
For encryption, set the \fIEncryptFlag\fR\& to \fItrue\fR\&\&. For decryption, set it to \fIfalse\fR\&\&.
.LP
See \fB examples in the User\&'s Guide\&.\fR\& 
.RE
.LP
.nf

.B
crypto_update(State, Data) -> Result | descriptive_error()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
State = \fBcrypto_state()\fR\&
.br
Data = iodata()
.br
Result = binary()
.br
.RE
.RE
.RS
.LP
Part of the \fBnew API\fR\&\&. It does an actual crypto operation on a part of the full text\&. If the part is less than a number of full blocks, only the full blocks (possibly none) are encrypted or decrypted and the remaining bytes are saved to the next \fIcrypto_update\fR\& operation\&. The \fIState\fR\& should be created with \fBcrypto_init/3\fR\& or \fBcrypto_init/4\fR\&\&.
.LP
See \fB examples in the User\&'s Guide\&.\fR\& 
.RE
.LP
.nf

.B
crypto_dyn_iv_init(Cipher, Key, EncryptFlag) ->
.B
                      State | descriptive_error()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Cipher = \fBcipher_iv()\fR\&
.br
Key = iodata()
.br
EncryptFlag = boolean()
.br
State = \fBcrypto_state()\fR\&
.br
.RE
.RE
.RS
.LP
Part of the \fBnew API\fR\&\&. Initializes a series of encryptions or decryptions where the IV is provided later\&. The actual encryption or decryption is done by \fBcrypto_dyn_iv_update/3\fR\&\&.
.LP
For encryption, set the \fIEncryptFlag\fR\& to \fItrue\fR\&\&. For decryption, set it to \fIfalse\fR\&\&.
.RE
.LP
.nf

.B
crypto_dyn_iv_update(State, Data, IV) ->
.B
                        Result | descriptive_error()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
State = \fBcrypto_state()\fR\&
.br
Data = IV = iodata()
.br
Result = binary()
.br
.RE
.RE
.RS
.LP
Part of the \fBnew API\fR\&\&. Do an actual crypto operation on a part of the full text and the IV is supplied for each part\&. The \fIState\fR\& should be created with \fBcrypto_dyn_iv_init/3\fR\&\&.
.RE
.LP
.nf

.B
crypto_one_time(Cipher, Key, Data, EncryptFlag) ->
.B
                   Result | descriptive_error()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Cipher = \fBcipher_no_iv()\fR\&
.br
Key = Data = iodata()
.br
EncryptFlag = boolean()
.br
Result = binary()
.br
.RE
.RE
.RS
.LP
As \fBcrypto_one_time/5\fR\& but for ciphers without IVs\&.
.RE
.LP
.nf

.B
crypto_one_time(Cipher, Key, IV, Data, EncryptFlag) ->
.B
                   Result | descriptive_error()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Cipher = \fBcipher_iv()\fR\&
.br
Key = IV = Data = iodata()
.br
EncryptFlag = boolean()
.br
Result = binary()
.br
.RE
.RE
.RS
.LP
Part of the \fBnew API\fR\&\&. Do a complete encrypt or decrypt of the full text in the argument \fIData\fR\&\&.
.LP
For encryption, set the \fIEncryptFlag\fR\& to \fItrue\fR\&\&. For decryption, set it to \fIfalse\fR\&\&.
.LP
See \fBexamples in the User\&'s Guide\&.\fR\& 
.RE
.LP
.nf

.B
crypto_one_time_aead(Cipher, Key, IV, InText, AAD,
.B
                     EncFlag :: true) ->
.B
                        Result | descriptive_error()
.br
.fi
.br
.nf

.B
crypto_one_time_aead(Cipher, Key, IV, InText, AAD, TagOrTagLength,
.B
                     EncFlag) ->
.B
                        Result | descriptive_error()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Cipher = \fBcipher_aead()\fR\&
.br
Key = IV = InText = AAD = iodata()
.br
TagOrTagLength = EncryptTagLength | DecryptTag
.br
EncryptTagLength = integer() >= 0
.br
DecryptTag = iodata()
.br
EncFlag = boolean()
.br
Result = EncryptResult | DecryptResult
.br
EncryptResult = {OutCryptoText, OutTag}
.br
DecryptResult = OutPlainText | error
.br
OutCryptoText = OutTag = OutPlainText = binary()
.br
.RE
.RE
.RS
.LP
Part of the \fBnew API\fR\&\&. Do a complete encrypt or decrypt with an AEAD cipher of the full text\&.
.LP
For encryption, set the \fIEncryptFlag\fR\& to \fItrue\fR\& and set the \fITagOrTagLength\fR\& to the wanted size (in bytes) of the tag, that is, the tag length\&. If the default length is wanted, the \fIcrypto_aead/6\fR\& form may be used\&.
.LP
For decryption, set the \fIEncryptFlag\fR\& to \fIfalse\fR\& and put the tag to be checked in the argument \fITagOrTagLength\fR\&\&.
.LP
See \fBexamples in the User\&'s Guide\&.\fR\& 
.RE
.LP
.nf

.B
supports(Type) -> Support
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Type = hashs | ciphers | public_keys | macs | curves | rsa_opts
.br
Support = Hashs | Ciphers | PKs | Macs | Curves | RSAopts
.br
Hashs = 
.br
    [\fBsha1()\fR\& |
.br
     \fBsha2()\fR\& |
.br
     \fBsha3()\fR\& |
.br
     \fBblake2()\fR\& |
.br
     ripemd160 |
.br
     \fBcompatibility_only_hash()\fR\&]
.br
Ciphers = [\fBcipher()\fR\&]
.br
PKs = [rsa | dss | ecdsa | dh | ecdh | ec_gf2m]
.br
Macs = [hmac | cmac | poly1305]
.br
Curves = 
.br
    [\fBec_named_curve()\fR\& | \fBedwards_curve_dh()\fR\& | \fBedwards_curve_ed()\fR\&]
.br
RSAopts = [\fBrsa_sign_verify_opt()\fR\& | \fBrsa_opt()\fR\&]
.br
.RE
.RE
.RS
.LP
Can be used to determine which crypto algorithms that are supported by the underlying libcrypto library
.LP
See \fBhash_info/1\fR\& and \fBcipher_info/1\fR\& for information about the hash and cipher algorithms\&.
.RE
.LP
.nf

.B
mac(Type :: poly1305, Key, Data) -> Mac | descriptive_error()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Key = Data = iodata()
.br
Mac = binary()
.br
.RE
.RE
.RS
.LP
Short for \fBmac(Type, undefined, Key, Data)\fR\&\&.
.RE
.LP
.nf

.B
mac(Type, SubType, Key, Data) -> Mac | descriptive_error()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Type = hmac | cmac | poly1305
.br
SubType = 
.br
    \fBhmac_hash_algorithm()\fR\& | \fBcmac_cipher_algorithm()\fR\& | undefined
.br
Key = Data = iodata()
.br
Mac = binary()
.br
.RE
.RE
.RS
.LP
Computes a MAC (Message Authentication Code) of type \fIType\fR\& from \fIData\fR\&\&.
.LP
\fISubType\fR\& depends on the MAC \fIType\fR\&:
.RS 2
.TP 2
*
For \fIhmac\fR\& it is a hash algorithm, see \fBAlgorithm Details\fR\& in the User\&'s Guide\&. 
.LP
.TP 2
*
For \fIcmac\fR\& it is a cipher suitable for cmac, see \fBAlgorithm Details\fR\& in the User\&'s Guide\&. 
.LP
.TP 2
*
For \fIpoly1305\fR\& it should be set to \fIundefined\fR\& or the \fBmac/2\fR\& function could be used instead, see \fBAlgorithm Details\fR\& in the User\&'s Guide\&. 
.LP
.RE

.LP
\fIKey\fR\& is the authentication key with a length according to the \fIType\fR\& and \fISubType\fR\&\&. The key length could be found with the \fBhash_info/1\fR\& (\fIhmac\fR\&) for and \fBcipher_info/1\fR\& (\fIcmac\fR\&) functions\&. For \fIpoly1305\fR\& the key length is 32 bytes\&. Note that the cryptographic quality of the key is not checked\&.
.LP
The \fIMac\fR\& result will have a default length depending on the \fIType\fR\& and \fISubType\fR\&\&. To set a shorter length, use \fBmacN/4\fR\& or \fBmacN/5\fR\& instead\&. The default length is documented in \fBAlgorithm Details\fR\& in the User\&'s Guide\&.
.RE
.LP
.nf

.B
macN(Type :: poly1305, Key, Data, MacLength) ->
.B
        Mac | descriptive_error()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Key = Data = iodata()
.br
Mac = binary()
.br
MacLength = integer() >= 1
.br
.RE
.RE
.RS
.LP
Short for \fBmacN(Type, undefined, Key, Data, MacLength)\fR\&\&.
.RE
.LP
.nf

.B
macN(Type, SubType, Key, Data, MacLength) ->
.B
        Mac | descriptive_error()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Type = hmac | cmac | poly1305
.br
SubType = 
.br
    \fBhmac_hash_algorithm()\fR\& | \fBcmac_cipher_algorithm()\fR\& | undefined
.br
Key = Data = iodata()
.br
Mac = binary()
.br
MacLength = integer() >= 1
.br
.RE
.RE
.RS
.LP
Computes a MAC (Message Authentication Code) as \fBmac/3\fR\& and \fBmac/4\fR\& but \fIMacLength\fR\& will limit the size of the resultant \fIMac\fR\& to at most \fIMacLength\fR\& bytes\&. Note that if \fIMacLength\fR\& is greater than the actual number of bytes returned from the underlying hash, the returned hash will have that shorter length instead\&.
.LP
The max \fIMacLength\fR\& is documented in \fBAlgorithm Details\fR\& in the User\&'s Guide\&.
.RE
.LP
.nf

.B
mac_init(Type :: poly1305, Key) -> State | descriptive_error()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Key = iodata()
.br
State = \fBmac_state()\fR\&
.br
.RE
.RE
.RS
.LP
Short for \fBmac_init(Type, undefined, Key)\fR\&\&.
.RE
.LP
.nf

.B
mac_init(Type, SubType, Key) -> State | descriptive_error()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Type = hmac | cmac | poly1305
.br
SubType = 
.br
    \fBhmac_hash_algorithm()\fR\& | \fBcmac_cipher_algorithm()\fR\& | undefined
.br
Key = iodata()
.br
State = \fBmac_state()\fR\&
.br
.RE
.RE
.RS
.LP
Initializes the context for streaming MAC operations\&.
.LP
\fIType\fR\& determines which mac algorithm to use in the MAC operation\&.
.LP
\fISubType\fR\& depends on the MAC \fIType\fR\&:
.RS 2
.TP 2
*
For \fIhmac\fR\& it is a hash algorithm, see \fBAlgorithm Details\fR\& in the User\&'s Guide\&. 
.LP
.TP 2
*
For \fIcmac\fR\& it is a cipher suitable for cmac, see \fBAlgorithm Details\fR\& in the User\&'s Guide\&. 
.LP
.TP 2
*
For \fIpoly1305\fR\& it should be set to \fIundefined\fR\& or the \fBmac/2\fR\& function could be used instead, see \fBAlgorithm Details\fR\& in the User\&'s Guide\&. 
.LP
.RE

.LP
\fIKey\fR\& is the authentication key with a length according to the \fIType\fR\& and \fISubType\fR\&\&. The key length could be found with the \fBhash_info/1\fR\& (\fIhmac\fR\&) for and \fBcipher_info/1\fR\& (\fIcmac\fR\&) functions\&. For \fIpoly1305\fR\& the key length is 32 bytes\&. Note that the cryptographic quality of the key is not checked\&.
.LP
The returned \fIState\fR\& should be used in one or more subsequent calls to \fBmac_update/2\fR\&\&. The MAC value is finally returned by calling \fBmac_final/1\fR\& or \fBmac_finalN/2\fR\&\&.
.LP
See \fB examples in the User\&'s Guide\&.\fR\& 
.RE
.LP
.nf

.B
mac_update(State0, Data) -> State | descriptive_error()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Data = iodata()
.br
State0 = State = \fBmac_state()\fR\&
.br
.RE
.RE
.RS
.LP
Updates the MAC represented by \fIState0\fR\& using the given \fIData\fR\& which could be of any length\&.
.LP
The \fIState0\fR\& is the State value originally from a MAC init function, that is \fBmac_init/2\fR\&, \fBmac_init/3\fR\& or a previous call of \fImac_update/2\fR\&\&. The value \fIState0\fR\& is returned unchanged by the function as \fIState\fR\&\&.
.RE
.LP
.nf

.B
mac_final(State) -> Mac | descriptive_error()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
State = \fBmac_state()\fR\&
.br
Mac = binary()
.br
.RE
.RE
.RS
.LP
Finalizes the MAC operation referenced by \fIState\fR\&\&. The \fIMac\fR\& result will have a default length depending on the \fIType\fR\& and \fISubType\fR\& in the \fBmac_init/2,3\fR\& call\&. To set a shorter length, use \fBmac_finalN/2\fR\& instead\&. The default length is documented in \fBAlgorithm Details\fR\& in the User\&'s Guide\&.
.RE
.LP
.nf

.B
mac_finalN(State, MacLength) -> Mac | descriptive_error()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
State = \fBmac_state()\fR\&
.br
MacLength = integer() >= 1
.br
Mac = binary()
.br
.RE
.RE
.RS
.LP
Finalizes the MAC operation referenced by \fIState\fR\&\&.
.LP
\fIMac\fR\& will be a binary with at most \fIMacLength\fR\& bytes\&. Note that if \fIMacLength\fR\& is greater than the actual number of bytes returned from the underlying hash, the returned hash will have that shorter length instead\&.
.LP
The max \fIMacLength\fR\& is documented in \fBAlgorithm Details\fR\& in the User\&'s Guide\&.
.RE
.SH "API KEPT FROM PREVIOUS VERSIONS"

.SH EXPORTS
.LP
.nf

.B
bytes_to_integer(Bin :: binary()) -> integer()
.br
.fi
.br
.RS
.LP
Convert binary representation, of an integer, to an Erlang integer\&.
.RE
.LP
.nf

.B
compute_key(Type, OthersPublicKey, MyPrivateKey, Params) ->
.B
               SharedSecret
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Type = dh | ecdh | srp
.br
SharedSecret = binary()
.br
OthersPublicKey = \fBdh_public()\fR\& | \fBecdh_public()\fR\& | \fBsrp_public()\fR\&
.br
MyPrivateKey = 
.br
    \fBdh_private()\fR\& | \fBecdh_private()\fR\& | {\fBsrp_public()\fR\&, \fBsrp_private()\fR\&}
.br
Params = \fBdh_params()\fR\& | \fBecdh_params()\fR\& | \fBsrp_comp_params()\fR\&
.br
.RE
.RE
.RS
.LP
Computes the shared secret from the private key and the other party\&'s public key\&. See also \fBpublic_key:compute_key/2\fR\& 
.RE
.LP
.nf

.B
exor(Bin1 :: iodata(), Bin2 :: iodata()) -> binary()
.br
.fi
.br
.RS
.LP
Performs bit-wise XOR (exclusive or) on the data supplied\&.
.RE
.LP
.nf

.B
generate_key(Type, Params) -> {PublicKey, PrivKeyOut}
.br
.fi
.br
.nf

.B
generate_key(Type, Params, PrivKeyIn) -> {PublicKey, PrivKeyOut}
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Type = dh | ecdh | rsa | srp
.br
PublicKey = 
.br
    \fBdh_public()\fR\& | \fBecdh_public()\fR\& | \fBrsa_public()\fR\& | \fBsrp_public()\fR\&
.br
PrivKeyIn = 
.br
    undefined |
.br
    \fBdh_private()\fR\& |
.br
    \fBecdh_private()\fR\& |
.br
    \fBrsa_private()\fR\& |
.br
    {\fBsrp_public()\fR\&, \fBsrp_private()\fR\&}
.br
PrivKeyOut = 
.br
    \fBdh_private()\fR\& |
.br
    \fBecdh_private()\fR\& |
.br
    \fBrsa_private()\fR\& |
.br
    {\fBsrp_public()\fR\&, \fBsrp_private()\fR\&}
.br
Params = 
.br
    \fBdh_params()\fR\& | \fBecdh_params()\fR\& | \fBrsa_params()\fR\& | \fBsrp_comp_params()\fR\&
.br
.RE
.RE
.RS
.LP
Generates a public key of type \fIType\fR\&\&. See also \fBpublic_key:generate_key/1\fR\&\&. May raise exception:
.RS 2
.TP 2
*
\fIerror:badarg\fR\&: an argument is of wrong type or has an illegal value,
.LP
.TP 2
*
\fIerror:low_entropy\fR\&: the random generator failed due to lack of secure "randomness",
.LP
.TP 2
*
\fIerror:computation_failed\fR\&: the computation fails of another reason than \fIlow_entropy\fR\&\&.
.LP
.RE

.LP

.RS -4
.B
Note:
.RE
RSA key generation is only available if the runtime was built with dirty scheduler support\&. Otherwise, attempting to generate an RSA key will raise exception \fIerror:notsup\fR\&\&.

.RE
.LP
.nf

.B
hash(Type, Data) -> Digest
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Type = \fBhash_algorithm()\fR\&
.br
Data = iodata()
.br
Digest = binary()
.br
.RE
.RE
.RS
.LP
Computes a message digest of type \fIType\fR\& from \fIData\fR\&\&.
.LP
May raise exception \fIerror:notsup\fR\& in case the chosen \fIType\fR\& is not supported by the underlying libcrypto implementation\&.
.RE
.LP
.nf

.B
hash_init(Type) -> State
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Type = \fBhash_algorithm()\fR\&
.br
State = \fBhash_state()\fR\&
.br
.RE
.RE
.RS
.LP
Initializes the context for streaming hash operations\&. \fIType\fR\& determines which digest to use\&. The returned context should be used as argument to \fBhash_update\fR\&\&.
.LP
May raise exception \fIerror:notsup\fR\& in case the chosen \fIType\fR\& is not supported by the underlying libcrypto implementation\&.
.RE
.LP
.nf

.B
hash_update(State, Data) -> NewState
.br
.fi
.br
.RS
.LP
Types:

.RS 3
State = NewState = \fBhash_state()\fR\&
.br
Data = iodata()
.br
.RE
.RE
.RS
.LP
Updates the digest represented by \fIContext\fR\& using the given \fIData\fR\&\&. \fIContext\fR\& must have been generated using \fBhash_init\fR\& or a previous call to this function\&. \fIData\fR\& can be any length\&. \fINewContext\fR\& must be passed into the next call to \fIhash_update\fR\& or \fBhash_final\fR\&\&.
.RE
.LP
.nf

.B
hash_final(State) -> Digest
.br
.fi
.br
.RS
.LP
Types:

.RS 3
State = \fBhash_state()\fR\&
.br
Digest = binary()
.br
.RE
.RE
.RS
.LP
Finalizes the hash operation referenced by \fIContext\fR\& returned from a previous call to \fBhash_update\fR\&\&. The size of \fIDigest\fR\& is determined by the type of hash function used to generate it\&.
.RE
.LP
.nf

.B
info_fips() -> not_supported | not_enabled | enabled
.br
.fi
.br
.RS
.LP
Provides information about the FIPS operating status of crypto and the underlying libcrypto library\&. If crypto was built with FIPS support this can be either \fIenabled\fR\& (when running in FIPS mode) or \fInot_enabled\fR\&\&. For other builds this value is always \fInot_supported\fR\&\&.
.LP
See \fBenable_fips_mode/1\fR\& about how to enable FIPS mode\&.
.LP

.RS -4
.B
Warning:
.RE
In FIPS mode all non-FIPS compliant algorithms are disabled and raise exception \fIerror:notsup\fR\&\&. Check \fBsupports\fR\& that in FIPS mode returns the restricted list of available algorithms\&.

.RE
.LP
.nf

.B
enable_fips_mode(Enable) -> Result
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Enable = Result = boolean()
.br
.RE
.RE
.RS
.LP
Enables (\fIEnable = true\fR\&) or disables (\fIEnable = false\fR\&) FIPS mode\&. Returns \fItrue\fR\& if the operation was successful or \fIfalse\fR\& otherwise\&.
.LP
Note that to enable FIPS mode succesfully, OTP must be built with the configure option \fI--enable-fips\fR\&, and the underlying libcrypto must also support FIPS\&.
.LP
See also \fBinfo_fips/0\fR\&\&.
.RE
.LP
.nf

.B
info_lib() -> [{Name, VerNum, VerStr}]
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Name = binary()
.br
VerNum = integer()
.br
VerStr = binary()
.br
.RE
.RE
.RS
.LP
Provides the name and version of the libraries used by crypto\&.
.LP
\fIName\fR\& is the name of the library\&. \fIVerNum\fR\& is the numeric version according to the library\&'s own versioning scheme\&. \fIVerStr\fR\& contains a text variant of the version\&.
.LP
.nf

> info_lib()\&.
[{<<"OpenSSL">>,269484095,<<"OpenSSL 1.1.0c  10 Nov 2016"">>}]
        
.fi
.LP

.RS -4
.B
Note:
.RE
From OTP R16 the \fInumeric version\fR\& represents the version of the OpenSSL \fIheader files\fR\& (\fIopenssl/opensslv\&.h\fR\&) used when crypto was compiled\&. The text variant represents the libcrypto library used at runtime\&. In earlier OTP versions both numeric and text was taken from the library\&.

.RE
.LP
.nf

.B
hash_info(Type) -> Result | run_time_error()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Type = \fBhash_algorithm()\fR\&
.br
Result = 
.br
    #{size := integer(),
.br
      block_size := integer(),
.br
      type := integer()}
.br
.RE
.RE
.RS
.LP
Provides a map with information about block_size, size and possibly other properties of the hash algorithm in question\&.
.LP
For a list of supported hash algorithms, see \fBsupports/0\fR\&\&.
.RE
.LP
.nf

.B
cipher_info(Type) -> Result | run_time_error()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Type = \fBcipher()\fR\&
.br
Result = 
.br
    #{key_length := integer(),
.br
      iv_length := integer(),
.br
      block_size := integer(),
.br
      mode := CipherModes,
.br
      type := undefined | integer()}
.br
CipherModes = 
.br
    undefined | cbc_mode | ccm_mode | cfb_mode | ctr_mode |
.br
    ecb_mode | gcm_mode | ige_mode | ocb_mode | ofb_mode |
.br
    wrap_mode | xts_mode
.br
.RE
.RE
.RS
.LP
Provides a map with information about block_size, key_length, iv_length and possibly other properties of the cipher algorithm in question\&.
.LP

.RS -4
.B
Note:
.RE
The ciphers \fIaes_cbc\fR\&, \fIaes_cfb8\fR\&, \fIaes_cfb128\fR\&, \fIaes_ctr\fR\&, \fIaes_ecb\fR\&, \fIaes_gcm\fR\& and \fIaes_ccm\fR\& has no keylength in the \fIType\fR\& as opposed to for example \fIaes_128_ctr\fR\&\&. They adapt to the length of the key provided in the encrypt and decrypt function\&. Therefor it is impossible to return a valid keylength in the map\&.
.LP
Always use a \fIType\fR\& with an explicit key length,

.LP
For a list of supported cipher algorithms, see \fBsupports/0\fR\&\&.
.RE
.LP
.nf

.B
mod_pow(N, P, M) -> Result
.br
.fi
.br
.RS
.LP
Types:

.RS 3
N = P = M = binary() | integer()
.br
Result = binary() | error
.br
.RE
.RE
.RS
.LP
Computes the function \fIN^P mod M\fR\&\&.
.RE
.LP
.nf

.B
next_iv(Type :: cbc_cipher(), Data) -> NextIVec
.br
.fi
.br
.nf

.B
next_iv(Type :: des_cfb, Data, IVec) -> NextIVec
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Data = iodata()
.br
IVec = NextIVec = binary()
.br
.RE
.RE
.RS
.LP
Returns the initialization vector to be used in the next iteration of encrypt/decrypt of type \fIType\fR\&\&. \fIData\fR\& is the encrypted data from the previous iteration step\&. The \fIIVec\fR\& argument is only needed for \fIdes_cfb\fR\& as the vector used in the previous iteration step\&.
.RE
.LP
.nf

.B
private_decrypt(Algorithm, CipherText, PrivateKey, Options) ->
.B
                   PlainText
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Algorithm = \fBpk_encrypt_decrypt_algs()\fR\&
.br
CipherText = binary()
.br
PrivateKey = \fBrsa_private()\fR\& | \fBengine_key_ref()\fR\&
.br
Options = \fBpk_encrypt_decrypt_opts()\fR\&
.br
PlainText = binary()
.br
.RE
.RE
.RS
.LP
Decrypts the \fICipherText\fR\&, encrypted with \fBpublic_encrypt/4\fR\& (or equivalent function) using the \fIPrivateKey\fR\&, and returns the plaintext (message digest)\&. This is a low level signature verification operation used for instance by older versions of the SSL protocol\&. See also \fBpublic_key:decrypt_private/[2,3]\fR\& 
.RE
.LP
.nf

.B
private_encrypt(Algorithm, PlainText, PrivateKey, Options) ->
.B
                   CipherText
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Algorithm = \fBpk_encrypt_decrypt_algs()\fR\&
.br
PlainText = binary()
.br
PrivateKey = \fBrsa_private()\fR\& | \fBengine_key_ref()\fR\&
.br
Options = \fBpk_encrypt_decrypt_opts()\fR\&
.br
CipherText = binary()
.br
.RE
.RE
.RS
.LP
Encrypts the \fIPlainText\fR\& using the \fIPrivateKey\fR\& and returns the ciphertext\&. This is a low level signature operation used for instance by older versions of the SSL protocol\&. See also \fBpublic_key:encrypt_private/[2,3]\fR\& 
.RE
.LP
.nf

.B
public_decrypt(Algorithm, CipherText, PublicKey, Options) ->
.B
                  PlainText
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Algorithm = \fBpk_encrypt_decrypt_algs()\fR\&
.br
CipherText = binary()
.br
PublicKey = \fBrsa_public()\fR\& | \fBengine_key_ref()\fR\&
.br
Options = \fBpk_encrypt_decrypt_opts()\fR\&
.br
PlainText = binary()
.br
.RE
.RE
.RS
.LP
Decrypts the \fICipherText\fR\&, encrypted with \fBprivate_encrypt/4\fR\&(or equivalent function) using the \fIPrivateKey\fR\&, and returns the plaintext (message digest)\&. This is a low level signature verification operation used for instance by older versions of the SSL protocol\&. See also \fBpublic_key:decrypt_public/[2,3]\fR\& 
.RE
.LP
.nf

.B
public_encrypt(Algorithm, PlainText, PublicKey, Options) ->
.B
                  CipherText
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Algorithm = \fBpk_encrypt_decrypt_algs()\fR\&
.br
PlainText = binary()
.br
PublicKey = \fBrsa_public()\fR\& | \fBengine_key_ref()\fR\&
.br
Options = \fBpk_encrypt_decrypt_opts()\fR\&
.br
CipherText = binary()
.br
.RE
.RE
.RS
.LP
Encrypts the \fIPlainText\fR\& (message digest) using the \fIPublicKey\fR\& and returns the \fICipherText\fR\&\&. This is a low level signature operation used for instance by older versions of the SSL protocol\&. See also \fBpublic_key:encrypt_public/[2,3]\fR\& 
.RE
.LP
.nf

.B
rand_seed(Seed :: binary()) -> ok
.br
.fi
.br
.RS
.LP
Set the seed for PRNG to the given binary\&. This calls the RAND_seed function from openssl\&. Only use this if the system you are running on does not have enough "randomness" built in\&. Normally this is when \fBstrong_rand_bytes/1\fR\& raises \fIerror:low_entropy\fR\&
.RE
.LP
.B
rand_uniform(Lo, Hi) -> N
.br
.RS
.LP
Types:

.RS 3
Lo, Hi, N = integer()
.br
.RE
.RE
.RS
.LP
Generate a random number \fIN, Lo =< N < Hi\&.\fR\& Uses the \fIcrypto\fR\& library pseudo-random number generator\&. \fIHi\fR\& must be larger than \fILo\fR\&\&.
.RE
.LP
.nf

.B
start() -> ok | {error, Reason :: term()}
.br
.fi
.br
.RS
.LP
Equivalent to application:start(crypto)\&.
.RE
.LP
.nf

.B
stop() -> ok | {error, Reason :: term()}
.br
.fi
.br
.RS
.LP
Equivalent to application:stop(crypto)\&.
.RE
.LP
.nf

.B
strong_rand_bytes(N :: integer() >= 0) -> binary()
.br
.fi
.br
.RS
.LP
Generates N bytes randomly uniform 0\&.\&.255, and returns the result in a binary\&. Uses a cryptographically secure prng seeded and periodically mixed with operating system provided entropy\&. By default this is the \fIRAND_bytes\fR\& method from OpenSSL\&.
.LP
May raise exception \fIerror:low_entropy\fR\& in case the random generator failed due to lack of secure "randomness"\&.
.RE
.LP
.nf

.B
rand_seed() -> rand:state()
.br
.fi
.br
.RS
.LP
Creates state object for \fBrandom number generation\fR\&, in order to generate cryptographically strong random numbers (based on OpenSSL\&'s \fIBN_rand_range\fR\&), and saves it in the process dictionary before returning it as well\&. See also \fBrand:seed/1\fR\& and \fBrand_seed_s/0\fR\&\&.
.LP
When using the state object from this function the \fBrand\fR\& functions using it may raise exception \fIerror:low_entropy\fR\& in case the random generator failed due to lack of secure "randomness"\&.
.LP
\fIExample\fR\&
.LP
.nf

_ = crypto:rand_seed(),
_IntegerValue = rand:uniform(42), % [1; 42]
_FloatValue = rand:uniform().     % [0.0; 1.0[
.fi
.RE
.LP
.nf

.B
rand_seed_s() -> rand:state()
.br
.fi
.br
.RS
.LP
Creates state object for \fBrandom number generation\fR\&, in order to generate cryptographically strongly random numbers (based on OpenSSL\&'s \fIBN_rand_range\fR\&)\&. See also \fBrand:seed_s/1\fR\&\&.
.LP
When using the state object from this function the \fBrand\fR\& functions using it may raise exception \fIerror:low_entropy\fR\& in case the random generator failed due to lack of secure "randomness"\&.
.LP

.RS -4
.B
Note:
.RE
The state returned from this function cannot be used to get a reproducable random sequence as from the other \fBrand\fR\& functions, since reproducability does not match cryptographically safe\&.
.LP
The only supported usage is to generate one distinct random sequence from this start state\&.

.RE
.LP
.B
rand_seed_alg(Alg) -> rand:state()
.br
.RS
.LP
Types:

.RS 3
Alg = crypto | crypto_cache
.br
.RE
.RE
.RS
.LP
Creates state object for \fBrandom number generation\fR\&, in order to generate cryptographically strong random numbers, and saves it in the process dictionary before returning it as well\&. See also \fBrand:seed/1\fR\& and \fBrand_seed_alg_s/1\fR\&\&.
.LP
When using the state object from this function the \fBrand\fR\& functions using it may raise exception \fIerror:low_entropy\fR\& in case the random generator failed due to lack of secure "randomness"\&.
.LP
\fIExample\fR\&
.LP
.nf

_ = crypto:rand_seed_alg(crypto_cache),
_IntegerValue = rand:uniform(42), % [1; 42]
_FloatValue = rand:uniform().     % [0.0; 1.0[
.fi
.RE
.LP
.B
rand_seed_alg(Alg, Seed) -> rand:state()
.br
.RS
.LP
Types:

.RS 3
Alg = crypto_aes
.br
.RE
.RE
.RS
.LP
Creates a state object for \fBrandom number generation\fR\&, in order to generate cryptographically unpredictable random numbers, and saves it in the process dictionary before returning it as well\&. See also \fBrand_seed_alg_s/2\fR\&\&.
.LP
\fIExample\fR\&
.LP
.nf

_ = crypto:rand_seed_alg(crypto_aes, "my seed"),
IntegerValue = rand:uniform(42), % [1; 42]
FloatValue = rand:uniform(),     % [0.0; 1.0[
_ = crypto:rand_seed_alg(crypto_aes, "my seed"),
IntegerValue = rand:uniform(42), % Same values
FloatValue = rand:uniform().     % again
	
.fi
.RE
.LP
.B
rand_seed_alg_s(Alg) -> rand:state()
.br
.RS
.LP
Types:

.RS 3
Alg = crypto | crypto_cache
.br
.RE
.RE
.RS
.LP
Creates state object for \fBrandom number generation\fR\&, in order to generate cryptographically strongly random numbers\&. See also \fBrand:seed_s/1\fR\&\&.
.LP
If \fIAlg\fR\& is \fIcrypto\fR\& this function behaves exactly like \fBrand_seed_s/0\fR\&\&.
.LP
If \fIAlg\fR\& is \fIcrypto_cache\fR\& this function fetches random data with OpenSSL\&'s \fIRAND_bytes\fR\& and caches it for speed using an internal word size of 56 bits that makes calculations fast on 64 bit machines\&.
.LP
When using the state object from this function the \fBrand\fR\& functions using it may raise exception \fIerror:low_entropy\fR\& in case the random generator failed due to lack of secure "randomness"\&.
.LP
The cache size can be changed from its default value using the \fB crypto app\&'s \fR\& configuration parameter \fIrand_cache_size\fR\&\&.
.LP
When using the state object from this function the \fBrand\fR\& functions using it may throw exception \fIlow_entropy\fR\& in case the random generator failed due to lack of secure "randomness"\&.
.LP

.RS -4
.B
Note:
.RE
The state returned from this function cannot be used to get a reproducable random sequence as from the other \fBrand\fR\& functions, since reproducability does not match cryptographically safe\&.
.LP
In fact since random data is cached some numbers may get reproduced if you try, but this is unpredictable\&.
.LP
The only supported usage is to generate one distinct random sequence from this start state\&.

.RE
.LP
.B
rand_seed_alg_s(Alg, Seed) -> rand:state()
.br
.RS
.LP
Types:

.RS 3
Alg = crypto_aes
.br
.RE
.RE
.RS
.LP
Creates a state object for \fBrandom number generation\fR\&, in order to generate cryptographically unpredictable random numbers\&. See also \fBrand_seed_alg/1\fR\&\&.
.LP
To get a long period the Xoroshiro928 generator from the \fBrand\fR\& module is used as a counter (with period 2^928 - 1) and the generator states are scrambled through AES to create 58-bit pseudo random values\&.
.LP
The result should be statistically completely unpredictable random values, since the scrambling is cryptographically strong and the period is ridiculously long\&. But the generated numbers are not to be regarded as cryptographically strong since there is no re-keying schedule\&.
.RS 2
.TP 2
*
If you need cryptographically strong random numbers use \fBrand_seed_alg_s/1\fR\& with \fIAlg =:= crypto\fR\& or \fIAlg =:= crypto_cache\fR\&\&.
.LP
.TP 2
*
If you need to be able to repeat the sequence use this function\&.
.LP
.TP 2
*
If you do not need the statistical quality of this function, there are faster algorithms in the \fBrand\fR\& module\&.
.LP
.RE

.LP
Thanks to the used generator the state object supports the \fB\fIrand:jump/0,1\fR\&\fR\& function with distance 2^512\&.
.LP
Numbers are generated in batches and cached for speed reasons\&. The cache size can be changed from its default value using the \fB crypto app\&'s \fR\& configuration parameter \fIrand_cache_size\fR\&\&.
.RE
.LP
.nf

.B
ec_curves() -> [EllipticCurve]
.br
.fi
.br
.RS
.LP
Types:

.RS 3
EllipticCurve = 
.br
    \fBec_named_curve()\fR\& | \fBedwards_curve_dh()\fR\& | \fBedwards_curve_ed()\fR\&
.br
.RE
.RE
.RS
.LP
Can be used to determine which named elliptic curves are supported\&.
.RE
.LP
.nf

.B
ec_curve(CurveName) -> ExplicitCurve
.br
.fi
.br
.RS
.LP
Types:

.RS 3
CurveName = \fBec_named_curve()\fR\&
.br
ExplicitCurve = \fBec_explicit_curve()\fR\&
.br
.RE
.RE
.RS
.LP
Return the defining parameters of a elliptic curve\&.
.RE
.LP
.nf

.B
sign(Algorithm, DigestType, Msg, Key) -> Signature
.br
.fi
.br
.nf

.B
sign(Algorithm, DigestType, Msg, Key, Options) -> Signature
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Algorithm = \fBpk_sign_verify_algs()\fR\&
.br
DigestType = 
.br
    \fBrsa_digest_type()\fR\& |
.br
    \fBdss_digest_type()\fR\& |
.br
    \fBecdsa_digest_type()\fR\& |
.br
    none
.br
Msg = iodata() | {digest, iodata()}
.br
Key = 
.br
    \fBrsa_private()\fR\& |
.br
    \fBdss_private()\fR\& |
.br
    [\fBecdsa_private()\fR\& | \fBecdsa_params()\fR\&] |
.br
    [\fBeddsa_private()\fR\& | \fBeddsa_params()\fR\&] |
.br
    \fBengine_key_ref()\fR\&
.br
Options = \fBpk_sign_verify_opts()\fR\&
.br
Signature = binary()
.br
.RE
.RE
.RS
.LP
Creates a digital signature\&.
.LP
The msg is either the binary "cleartext" data to be signed or it is the hashed value of "cleartext" i\&.e\&. the digest (plaintext)\&.
.LP
Algorithm \fIdss\fR\& can only be used together with digest type \fIsha\fR\&\&.
.LP
See also \fBpublic_key:sign/3\fR\&\&.
.RE
.LP
.nf

.B
verify(Algorithm, DigestType, Msg, Signature, Key) -> Result
.br
.fi
.br
.nf

.B
verify(Algorithm, DigestType, Msg, Signature, Key, Options) ->
.B
          Result
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Algorithm = \fBpk_sign_verify_algs()\fR\&
.br
DigestType = 
.br
    \fBrsa_digest_type()\fR\& | \fBdss_digest_type()\fR\& | \fBecdsa_digest_type()\fR\&
.br
Msg = iodata() | {digest, iodata()}
.br
Signature = binary()
.br
Key = 
.br
    \fBrsa_public()\fR\& |
.br
    \fBdss_public()\fR\& |
.br
    [\fBecdsa_public()\fR\& | \fBecdsa_params()\fR\&] |
.br
    [\fBeddsa_public()\fR\& | \fBeddsa_params()\fR\&] |
.br
    \fBengine_key_ref()\fR\&
.br
Options = \fBpk_sign_verify_opts()\fR\&
.br
Result = boolean()
.br
.RE
.RE
.RS
.LP
Verifies a digital signature
.LP
The msg is either the binary "cleartext" data to be signed or it is the hashed value of "cleartext" i\&.e\&. the digest (plaintext)\&.
.LP
Algorithm \fIdss\fR\& can only be used together with digest type \fIsha\fR\&\&.
.LP
See also \fBpublic_key:verify/4\fR\&\&.
.RE
.SH "ENGINE API"

.SH EXPORTS
.LP
.nf

.B
privkey_to_pubkey(Type, EnginePrivateKeyRef) -> PublicKey
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Type = rsa | dss
.br
EnginePrivateKeyRef = \fBengine_key_ref()\fR\&
.br
PublicKey = \fBrsa_public()\fR\& | \fBdss_public()\fR\&
.br
.RE
.RE
.RS
.LP
Fetches the corresponding public key from a private key stored in an Engine\&. The key must be of the type indicated by the Type parameter\&.
.RE
.LP
.nf

.B
engine_get_all_methods() -> Result
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Result = [\fBengine_method_type()\fR\&]
.br
.RE
.RE
.RS
.LP
Returns a list of all possible engine methods\&.
.LP
May raise exception \fIerror:notsup\fR\& in case there is no engine support in the underlying OpenSSL implementation\&.
.LP
See also the chapter \fBEngine Load\fR\& in the User\&'s Guide\&.
.RE
.LP
.nf

.B
engine_load(EngineId, PreCmds, PostCmds) -> Result
.br
.fi
.br
.RS
.LP
Types:

.RS 3
EngineId = \fBunicode:chardata()\fR\&
.br
PreCmds = PostCmds = [\fBengine_cmnd()\fR\&]
.br
Result = 
.br
    {ok, Engine :: \fBengine_ref()\fR\&} | {error, Reason :: term()}
.br
.RE
.RE
.RS
.LP
Loads the OpenSSL engine given by \fIEngineId\fR\& if it is available and then returns ok and an engine handle\&. This function is the same as calling \fIengine_load/4\fR\& with \fIEngineMethods\fR\& set to a list of all the possible methods\&. An error tuple is returned if the engine can\&'t be loaded\&.
.LP
The function raises a \fIerror:badarg\fR\& if the parameters are in wrong format\&. It may also raise the exception \fIerror:notsup\fR\& in case there is no engine support in the underlying OpenSSL implementation\&.
.LP
See also the chapter \fBEngine Load\fR\& in the User\&'s Guide\&.
.RE
.LP
.nf

.B
engine_load(EngineId, PreCmds, PostCmds, EngineMethods) -> Result
.br
.fi
.br
.RS
.LP
Types:

.RS 3
EngineId = \fBunicode:chardata()\fR\&
.br
PreCmds = PostCmds = [\fBengine_cmnd()\fR\&]
.br
EngineMethods = [\fBengine_method_type()\fR\&]
.br
Result = 
.br
    {ok, Engine :: \fBengine_ref()\fR\&} | {error, Reason :: term()}
.br
.RE
.RE
.RS
.LP
Loads the OpenSSL engine given by \fIEngineId\fR\& if it is available and then returns ok and an engine handle\&. An error tuple is returned if the engine can\&'t be loaded\&.
.LP
The function raises a \fIerror:badarg\fR\& if the parameters are in wrong format\&. It may also raise the exception \fIerror:notsup\fR\& in case there is no engine support in the underlying OpenSSL implementation\&.
.LP
See also the chapter \fBEngine Load\fR\& in the User\&'s Guide\&.
.RE
.LP
.nf

.B
engine_unload(Engine) -> Result
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Engine = \fBengine_ref()\fR\&
.br
Result = ok | {error, Reason :: term()}
.br
.RE
.RE
.RS
.LP
Unloads the OpenSSL engine given by \fIEngine\fR\&\&. An error tuple is returned if the engine can\&'t be unloaded\&.
.LP
The function raises a \fIerror:badarg\fR\& if the parameter is in wrong format\&. It may also raise the exception \fIerror:notsup\fR\& in case there is no engine support in the underlying OpenSSL implementation\&.
.LP
See also the chapter \fBEngine Load\fR\& in the User\&'s Guide\&.
.RE
.LP
.nf

.B
engine_by_id(EngineId) -> Result
.br
.fi
.br
.RS
.LP
Types:

.RS 3
EngineId = \fBunicode:chardata()\fR\&
.br
Result = 
.br
    {ok, Engine :: \fBengine_ref()\fR\&} | {error, Reason :: term()}
.br
.RE
.RE
.RS
.LP
Get a reference to an already loaded engine with \fIEngineId\fR\&\&. An error tuple is returned if the engine can\&'t be unloaded\&.
.LP
The function raises a \fIerror:badarg\fR\& if the parameter is in wrong format\&. It may also raise the exception \fIerror:notsup\fR\& in case there is no engine support in the underlying OpenSSL implementation\&.
.LP
See also the chapter \fBEngine Load\fR\& in the User\&'s Guide\&.
.RE
.LP
.nf

.B
engine_ctrl_cmd_string(Engine, CmdName, CmdArg) -> Result
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Engine = term()
.br
CmdName = CmdArg = \fBunicode:chardata()\fR\&
.br
Result = ok | {error, Reason :: term()}
.br
.RE
.RE
.RS
.LP
Sends ctrl commands to the OpenSSL engine given by \fIEngine\fR\&\&. This function is the same as calling \fIengine_ctrl_cmd_string/4\fR\& with \fIOptional\fR\& set to \fIfalse\fR\&\&.
.LP
The function raises a \fIerror:badarg\fR\& if the parameters are in wrong format\&. It may also raise the exception \fIerror:notsup\fR\& in case there is no engine support in the underlying OpenSSL implementation\&.
.RE
.LP
.nf

.B
engine_ctrl_cmd_string(Engine, CmdName, CmdArg, Optional) ->
.B
                          Result
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Engine = term()
.br
CmdName = CmdArg = \fBunicode:chardata()\fR\&
.br
Optional = boolean()
.br
Result = ok | {error, Reason :: term()}
.br
.RE
.RE
.RS
.LP
Sends ctrl commands to the OpenSSL engine given by \fIEngine\fR\&\&. \fIOptional\fR\& is a boolean argument that can relax the semantics of the function\&. If set to \fItrue\fR\& it will only return failure if the ENGINE supported the given command name but failed while executing it, if the ENGINE doesn\&'t support the command name it will simply return success without doing anything\&. In this case we assume the user is only supplying commands specific to the given ENGINE so we set this to \fIfalse\fR\&\&.
.LP
The function raises a \fIerror:badarg\fR\& if the parameters are in wrong format\&. It may also raise the exception \fIerror:notsup\fR\& in case there is no engine support in the underlying OpenSSL implementation\&.
.RE
.LP
.nf

.B
engine_add(Engine) -> Result
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Engine = \fBengine_ref()\fR\&
.br
Result = ok | {error, Reason :: term()}
.br
.RE
.RE
.RS
.LP
Add the engine to OpenSSL\&'s internal list\&.
.LP
The function raises a \fIerror:badarg\fR\& if the parameters are in wrong format\&. It may also raise the exception \fIerror:notsup\fR\& in case there is no engine support in the underlying OpenSSL implementation\&.
.RE
.LP
.nf

.B
engine_remove(Engine) -> Result
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Engine = \fBengine_ref()\fR\&
.br
Result = ok | {error, Reason :: term()}
.br
.RE
.RE
.RS
.LP
Remove the engine from OpenSSL\&'s internal list\&.
.LP
The function raises a \fIerror:badarg\fR\& if the parameters are in wrong format\&. It may also raise the exception \fIerror:notsup\fR\& in case there is no engine support in the underlying OpenSSL implementation\&.
.RE
.LP
.nf

.B
engine_get_id(Engine) -> EngineId
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Engine = \fBengine_ref()\fR\&
.br
EngineId = \fBunicode:chardata()\fR\&
.br
.RE
.RE
.RS
.LP
Return the ID for the engine, or an empty binary if there is no id set\&.
.LP
The function raises a \fIerror:badarg\fR\& if the parameters are in wrong format\&. It may also raise the exception \fIerror:notsup\fR\& in case there is no engine support in the underlying OpenSSL implementation\&.
.RE
.LP
.nf

.B
engine_get_name(Engine) -> EngineName
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Engine = \fBengine_ref()\fR\&
.br
EngineName = \fBunicode:chardata()\fR\&
.br
.RE
.RE
.RS
.LP
Return the name (eg a description) for the engine, or an empty binary if there is no name set\&.
.LP
The function raises a \fIerror:badarg\fR\& if the parameters are in wrong format\&. It may also raise the exception \fIerror:notsup\fR\& in case there is no engine support in the underlying OpenSSL implementation\&.
.RE
.LP
.nf

.B
engine_list() -> Result
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Result = [EngineId :: \fBunicode:chardata()\fR\&]
.br
.RE
.RE
.RS
.LP
List the id\&'s of all engines in OpenSSL\&'s internal list\&.
.LP
It may also raise the exception \fIerror:notsup\fR\& in case there is no engine support in the underlying OpenSSL implementation\&.
.LP
See also the chapter \fBEngine Load\fR\& in the User\&'s Guide\&.
.LP
May raise exception \fIerror:notsup\fR\& in case engine functionality is not supported by the underlying OpenSSL implementation\&.
.RE
.LP
.nf

.B
ensure_engine_loaded(EngineId, LibPath) -> Result
.br
.fi
.br
.RS
.LP
Types:

.RS 3
EngineId = LibPath = \fBunicode:chardata()\fR\&
.br
Result = 
.br
    {ok, Engine :: \fBengine_ref()\fR\&} | {error, Reason :: term()}
.br
.RE
.RE
.RS
.LP
Loads the OpenSSL engine given by \fIEngineId\fR\& and the path to the dynamic library implementing the engine\&. This function is the same as calling \fIensure_engine_loaded/3\fR\& with \fIEngineMethods\fR\& set to a list of all the possible methods\&. An error tuple is returned if the engine can\&'t be loaded\&.
.LP
The function raises a \fIerror:badarg\fR\& if the parameters are in wrong format\&. It may also raise the exception \fIerror:notsup\fR\& in case there is no engine support in the underlying OpenSSL implementation\&.
.LP
See also the chapter \fBEngine Load\fR\& in the User\&'s Guide\&.
.RE
.LP
.nf

.B
ensure_engine_loaded(EngineId, LibPath, EngineMethods) -> Result
.br
.fi
.br
.RS
.LP
Types:

.RS 3
EngineId = LibPath = \fBunicode:chardata()\fR\&
.br
EngineMethods = [\fBengine_method_type()\fR\&]
.br
Result = 
.br
    {ok, Engine :: \fBengine_ref()\fR\&} | {error, Reason :: term()}
.br
.RE
.RE
.RS
.LP
Loads the OpenSSL engine given by \fIEngineId\fR\& and the path to the dynamic library implementing the engine\&. This function differs from the normal engine_load in that sense it also add the engine id to the internal list in OpenSSL\&. Then in the following calls to the function it just fetch the reference to the engine instead of loading it again\&. An error tuple is returned if the engine can\&'t be loaded\&.
.LP
The function raises a \fIerror:badarg\fR\& if the parameters are in wrong format\&. It may also raise the exception \fIerror:notsup\fR\& in case there is no engine support in the underlying OpenSSL implementation\&.
.LP
See also the chapter \fBEngine Load\fR\& in the User\&'s Guide\&.
.RE
.LP
.nf

.B
ensure_engine_unloaded(Engine) -> Result
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Engine = \fBengine_ref()\fR\&
.br
Result = ok | {error, Reason :: term()}
.br
.RE
.RE
.RS
.LP
Unloads an engine loaded with the \fIensure_engine_loaded\fR\& function\&. It both removes the label from the OpenSSL internal engine list and unloads the engine\&. This function is the same as calling \fIensure_engine_unloaded/2\fR\& with \fIEngineMethods\fR\& set to a list of all the possible methods\&. An error tuple is returned if the engine can\&'t be unloaded\&.
.LP
The function raises a \fIerror:badarg\fR\& if the parameters are in wrong format\&. It may also raise the exception \fIerror:notsup\fR\& in case there is no engine support in the underlying OpenSSL implementation\&.
.LP
See also the chapter \fBEngine Load\fR\& in the User\&'s Guide\&.
.RE
.LP
.nf

.B
ensure_engine_unloaded(Engine, EngineMethods) -> Result
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Engine = \fBengine_ref()\fR\&
.br
EngineMethods = [\fBengine_method_type()\fR\&]
.br
Result = ok | {error, Reason :: term()}
.br
.RE
.RE
.RS
.LP
Unloads an engine loaded with the \fIensure_engine_loaded\fR\& function\&. It both removes the label from the OpenSSL internal engine list and unloads the engine\&. An error tuple is returned if the engine can\&'t be unloaded\&.
.LP
The function raises a \fIerror:badarg\fR\& if the parameters are in wrong format\&. It may also raise the exception \fIerror:notsup\fR\& in case there is no engine support in the underlying OpenSSL implementation\&.
.LP
See also the chapter \fBEngine Load\fR\& in the User\&'s Guide\&.
.RE
.SH "OLD API"

.SH EXPORTS
.LP
.nf

.B
block_encrypt(Type :: block_cipher_without_iv(),
.B
              Key :: key(),
.B
              PlainText :: iodata()) ->
.B
                 binary() | run_time_error()
.br
.fi
.br
.RS
.LP

.RS -4
.B
Dont:
.RE
Don\&'t use this function for new programs! Use \fBthe-new-api\fR\&\&.

.LP
Encrypt \fIPlainText\fR\& according to \fIType\fR\& block cipher\&.
.LP
May raise exception \fIerror:notsup\fR\& in case the chosen \fIType\fR\& is not supported by the underlying libcrypto implementation\&.
.LP
For keylengths and blocksizes see the \fBUser\&'s Guide\fR\&\&.
.RE
.LP
.nf

.B
block_decrypt(Type :: block_cipher_without_iv(),
.B
              Key :: key(),
.B
              Data :: iodata()) ->
.B
                 binary() | run_time_error()
.br
.fi
.br
.RS
.LP

.RS -4
.B
Dont:
.RE
Don\&'t use this function for new programs! Use \fBthe new api\fR\&\&.

.LP
Decrypt \fICipherText\fR\& according to \fIType\fR\& block cipher\&.
.LP
May raise exception \fIerror:notsup\fR\& in case the chosen \fIType\fR\& is not supported by the underlying libcrypto implementation\&.
.LP
For keylengths and blocksizes see the \fBUser\&'s Guide\fR\&\&.
.RE
.LP
.B
block_encrypt(Type, Key, Ivec, PlainText) -> CipherText | Error
.br
.B
block_encrypt(AeadType, Key, Ivec, {AAD, PlainText}) -> {CipherText, CipherTag} | Error
.br
.B
block_encrypt(aes_gcm | aes_ccm, Key, Ivec, {AAD, PlainText, TagLength}) -> {CipherText, CipherTag} | Error 
.br
.RS
.LP
Types:

.RS 3
Type = \fBblock_cipher_with_iv()\fR\&
.br
AeadType = \fBaead_cipher()\fR\&
.br
Key = \fBkey()\fR\& | \fBdes3_key()\fR\&
.br
PlainText = iodata()
.br
AAD = IVec = CipherText = CipherTag = binary()
.br
TagLength = 1\&.\&.16
.br
Error = \fBrun_time_error()\fR\&
.br
.RE
.RE
.RS
.LP

.RS -4
.B
Dont:
.RE
Don\&'t use this function for new programs! Use \fBthe new api\fR\&\&.

.LP
Encrypt \fIPlainText\fR\& according to \fIType\fR\& block cipher\&. \fIIVec\fR\& is an arbitrary initializing vector\&.
.LP
In AEAD (Authenticated Encryption with Associated Data) mode, encrypt \fIPlainText\fR\&according to \fIType\fR\& block cipher and calculate \fICipherTag\fR\& that also authenticates the \fIAAD\fR\& (Associated Authenticated Data)\&.
.LP
May raise exception \fIerror:notsup\fR\& in case the chosen \fIType\fR\& is not supported by the underlying libcrypto implementation\&.
.LP
For keylengths, iv-sizes and blocksizes see the \fBUser\&'s Guide\fR\&\&.
.RE
.LP
.B
block_decrypt(Type, Key, Ivec, CipherText) -> PlainText | Error
.br
.B
block_decrypt(AeadType, Key, Ivec, {AAD, CipherText, CipherTag}) -> PlainText | Error
.br
.RS
.LP
Types:

.RS 3
Type = \fBblock_cipher_with_iv()\fR\&
.br
AeadType = \fBaead_cipher()\fR\&
.br
Key = \fBkey()\fR\& | \fBdes3_key()\fR\&
.br
PlainText = iodata()
.br
AAD = IVec = CipherText = CipherTag = binary()
.br
Error = BadTag | \fBrun_time_error()\fR\&
.br
BadTag = error
.br
.RE
.RE
.RS
.LP

.RS -4
.B
Dont:
.RE
Don\&'t use this function for new programs! Use \fBthe new api\fR\&\&.

.LP
Decrypt \fICipherText\fR\& according to \fIType\fR\& block cipher\&. \fIIVec\fR\& is an arbitrary initializing vector\&.
.LP
In AEAD (Authenticated Encryption with Associated Data) mode, decrypt \fICipherText\fR\&according to \fIType\fR\& block cipher and check the authenticity the \fIPlainText\fR\& and \fIAAD\fR\& (Associated Authenticated Data) using the \fICipherTag\fR\&\&. May return \fIerror\fR\& if the decryption or validation fail\&'s
.LP
May raise exception \fIerror:notsup\fR\& in case the chosen \fIType\fR\& is not supported by the underlying libcrypto implementation\&.
.LP
For keylengths, iv-sizes and blocksizes see the \fBUser\&'s Guide\fR\&\&.
.RE
.LP
.nf

.B
stream_init(Type, Key) -> State | run_time_error()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Type = rc4
.br
Key = iodata()
.br
State = \fBstream_state()\fR\&
.br
.RE
.RE
.RS
.LP

.RS -4
.B
Dont:
.RE
Don\&'t use this function for new programs! Use \fBthe new api\fR\&\&.

.LP
Initializes the state for use in RC4 stream encryption \fBstream_encrypt\fR\& and \fBstream_decrypt\fR\&
.LP
For keylengths see the \fBUser\&'s Guide\fR\&\&.
.RE
.LP
.nf

.B
stream_init(Type, Key, IVec) -> State | run_time_error()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Type = \fBstream_cipher()\fR\&
.br
Key = iodata()
.br
IVec = binary()
.br
State = \fBstream_state()\fR\&
.br
.RE
.RE
.RS
.LP

.RS -4
.B
Dont:
.RE
Don\&'t use this function for new programs! Use \fBthe new api\fR\&\&.

.LP
Initializes the state for use in streaming AES encryption using Counter mode (CTR)\&. \fIKey\fR\& is the AES key and must be either 128, 192, or 256 bits long\&. \fIIVec\fR\& is an arbitrary initializing vector of 128 bits (16 bytes)\&. This state is for use with \fBstream_encrypt\fR\& and \fBstream_decrypt\fR\&\&.
.LP
For keylengths and iv-sizes see the \fBUser\&'s Guide\fR\&\&.
.RE
.LP
.nf

.B
stream_encrypt(State, PlainText) ->
.B
                  {NewState, CipherText} | run_time_error()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
State = \fBstream_state()\fR\&
.br
PlainText = iodata()
.br
NewState = \fBstream_state()\fR\&
.br
CipherText = iodata()
.br
.RE
.RE
.RS
.LP

.RS -4
.B
Dont:
.RE
Don\&'t use this function for new programs! Use \fBthe new api\fR\&\&.

.LP
Encrypts \fIPlainText\fR\& according to the stream cipher \fIType\fR\& specified in stream_init/3\&. \fIText\fR\& can be any number of bytes\&. The initial \fIState\fR\& is created using \fBstream_init\fR\&\&. \fINewState\fR\& must be passed into the next call to \fIstream_encrypt\fR\&\&.
.RE
.LP
.nf

.B
stream_decrypt(State, CipherText) ->
.B
                  {NewState, PlainText} | run_time_error()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
State = \fBstream_state()\fR\&
.br
CipherText = iodata()
.br
NewState = \fBstream_state()\fR\&
.br
PlainText = iodata()
.br
.RE
.RE
.RS
.LP

.RS -4
.B
Dont:
.RE
Don\&'t use this function for new programs! Use \fBthe new api\fR\&\&.

.LP
Decrypts \fICipherText\fR\& according to the stream cipher \fIType\fR\& specified in stream_init/3\&. \fIPlainText\fR\& can be any number of bytes\&. The initial \fIState\fR\& is created using \fBstream_init\fR\&\&. \fINewState\fR\& must be passed into the next call to \fIstream_decrypt\fR\&\&.
.RE
.LP
.nf

.B
supports() -> [Support]
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Support = 
.br
    {hashs, Hashs} |
.br
    {ciphers, Ciphers} |
.br
    {public_keys, PKs} |
.br
    {macs, Macs} |
.br
    {curves, Curves} |
.br
    {rsa_opts, RSAopts}
.br
Hashs = 
.br
    [\fBsha1()\fR\& |
.br
     \fBsha2()\fR\& |
.br
     \fBsha3()\fR\& |
.br
     \fBblake2()\fR\& |
.br
     ripemd160 |
.br
     \fBcompatibility_only_hash()\fR\&]
.br
Ciphers = [\fBcipher()\fR\&]
.br
PKs = [rsa | dss | ecdsa | dh | ecdh | ec_gf2m]
.br
Macs = [hmac | cmac | poly1305]
.br
Curves = 
.br
    [\fBec_named_curve()\fR\& | \fBedwards_curve_dh()\fR\& | \fBedwards_curve_ed()\fR\&]
.br
RSAopts = [\fBrsa_sign_verify_opt()\fR\& | \fBrsa_opt()\fR\&]
.br
.RE
.RE
.RS
.LP

.RS -4
.B
Dont:
.RE
Don\&'t use this function for new programs! Use \fBsupports/1\fR\& in \fBthe new api\fR\&\&.

.LP
Can be used to determine which crypto algorithms that are supported by the underlying libcrypto library
.LP
See \fBhash_info/1\fR\& and \fBcipher_info/1\fR\& for information about the hash and cipher algorithms\&.
.RE
.LP
.nf

.B
hmac(Type, Key, Data) -> Mac
.br
.fi
.br
.nf

.B
hmac(Type, Key, Data, MacLength) -> Mac
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Type = \fBhmac_hash_algorithm()\fR\&
.br
Key = Data = iodata()
.br
MacLength = integer()
.br
Mac = binary()
.br
.RE
.RE
.RS
.LP

.RS -4
.B
Dont:
.RE
Don\&'t use this function for new programs! Use \fBmac/4\fR\& or \fBmacN/5\fR\& in \fBthe new api\fR\&\&.

.LP
Computes a HMAC of type \fIType\fR\& from \fIData\fR\& using \fIKey\fR\& as the authentication key\&.
.LP
\fIMacLength\fR\& will limit the size of the resultant \fIMac\fR\&\&.
.RE
.LP
.nf

.B
hmac_init(Type, Key) -> State
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Type = \fBhmac_hash_algorithm()\fR\&
.br
Key = iodata()
.br
State = \fBhmac_state()\fR\&
.br
.RE
.RE
.RS
.LP

.RS -4
.B
Dont:
.RE
Don\&'t use this function for new programs! Use \fBmac_init/3\fR\& in \fBthe new api\fR\&\&.

.LP
Initializes the context for streaming HMAC operations\&. \fIType\fR\& determines which hash function to use in the HMAC operation\&. \fIKey\fR\& is the authentication key\&. The key can be any length\&.
.RE
.LP
.nf

.B
hmac_update(State, Data) -> NewState
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Data = iodata()
.br
State = NewState = \fBhmac_state()\fR\&
.br
.RE
.RE
.RS
.LP

.RS -4
.B
Dont:
.RE
Don\&'t use this function for new programs! Use \fBmac_update/2\fR\& in \fBthe new api\fR\&\&.

.LP
Updates the HMAC represented by \fIContext\fR\& using the given \fIData\fR\&\&. \fIContext\fR\& must have been generated using an HMAC init function (such as \fBhmac_init\fR\&)\&. \fIData\fR\& can be any length\&. \fINewContext\fR\& must be passed into the next call to \fIhmac_update\fR\& or to one of the functions \fBhmac_final\fR\& and \fBhmac_final_n\fR\& 
.LP

.RS -4
.B
Warning:
.RE
Do not use a \fIContext\fR\& as argument in more than one call to hmac_update or hmac_final\&. The semantics of reusing old contexts in any way is undefined and could even crash the VM in earlier releases\&. The reason for this limitation is a lack of support in the underlying libcrypto API\&.

.RE
.LP
.nf

.B
hmac_final(State) -> Mac
.br
.fi
.br
.RS
.LP
Types:

.RS 3
State = \fBhmac_state()\fR\&
.br
Mac = binary()
.br
.RE
.RE
.RS
.LP

.RS -4
.B
Dont:
.RE
Don\&'t use this function for new programs! Use \fBmac_final/1\fR\& in \fBthe new api\fR\&\&.

.LP
Finalizes the HMAC operation referenced by \fIContext\fR\&\&. The size of the resultant MAC is determined by the type of hash function used to generate it\&.
.RE
.LP
.nf

.B
hmac_final_n(State, HashLen) -> Mac
.br
.fi
.br
.RS
.LP
Types:

.RS 3
State = \fBhmac_state()\fR\&
.br
HashLen = integer()
.br
Mac = binary()
.br
.RE
.RE
.RS
.LP

.RS -4
.B
Dont:
.RE
Don\&'t use this function for new programs! Use \fBmac_finalN/2\fR\& in \fBthe new api\fR\&\&.

.LP
Finalizes the HMAC operation referenced by \fIContext\fR\&\&. \fIHashLen\fR\& must be greater than zero\&. \fIMac\fR\& will be a binary with at most \fIHashLen\fR\& bytes\&. Note that if HashLen is greater than the actual number of bytes returned from the underlying hash, the returned hash will have fewer than \fIHashLen\fR\& bytes\&.
.RE
.LP
.nf

.B
cmac(Type, Key, Data) -> Mac
.br
.fi
.br
.nf

.B
cmac(Type, Key, Data, MacLength) -> Mac
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Type = 
.br
    \fBcbc_cipher()\fR\& |
.br
    \fBcfb_cipher()\fR\& |
.br
    blowfish_cbc | des_ede3 | rc2_cbc
.br
Key = Data = iodata()
.br
MacLength = integer()
.br
Mac = binary()
.br
.RE
.RE
.RS
.LP

.RS -4
.B
Dont:
.RE
Don\&'t use this function for new programs! Use \fBmac/4\fR\& or \fBmacN/5\fR\& in \fBthe new api\fR\&\&.

.LP
Computes a CMAC of type \fIType\fR\& from \fIData\fR\& using \fIKey\fR\& as the authentication key\&.
.LP
\fIMacLength\fR\& will limit the size of the resultant \fIMac\fR\&\&.
.RE
.LP
.nf

.B
poly1305(Key :: iodata(), Data :: iodata()) -> Mac
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Mac = binary()
.br
.RE
.RE
.RS
.LP

.RS -4
.B
Dont:
.RE
Don\&'t use this function for new programs! Use \fBmac/3\fR\& or \fBmacN/4\fR\& in \fBthe new api\fR\&\&.

.LP
Computes a POLY1305 message authentication code (\fIMac\fR\&) from \fIData\fR\& using \fIKey\fR\& as the authentication key\&.
.RE